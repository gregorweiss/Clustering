<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>clustering: Clustering::MPP Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">clustering 0.13_beta</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceClustering.html">Clustering</a></li><li class="navelem"><a class="el" href="namespaceClustering_1_1MPP.html">MPP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Clustering::MPP Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>functions related to "Most Probable Path"-clustering  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aab655de2feb4b56dd87bcc0fc6f13974"><td class="memItemLeft" align="right" valign="top"><a id="aab655de2feb4b56dd87bcc0fc6f13974"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> = boost::numeric::ublas::mapped_matrix&lt; float &gt;</td></tr>
<tr class="memdesc:aab655de2feb4b56dd87bcc0fc6f13974"><td class="mdescLeft">&#160;</td><td class="mdescRight">BOOST implementation of a sparse matrix for floats. <br /></td></tr>
<tr class="separator:aab655de2feb4b56dd87bcc0fc6f13974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c585c21d2f99427a870eb96ccc0510"><td class="memItemLeft" align="right" valign="top"><a id="a39c585c21d2f99427a870eb96ccc0510"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#a39c585c21d2f99427a870eb96ccc0510">Neighborhood</a> = <a class="el" href="namespaceClustering_1_1Tools.html#ad2b6f4886446247db27ece196d76575c">Clustering::Tools::Neighborhood</a></td></tr>
<tr class="memdesc:a39c585c21d2f99427a870eb96ccc0510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Neighborhood per frame. <br /></td></tr>
<tr class="separator:a39c585c21d2f99427a870eb96ccc0510"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acec15a02b2a18eb8ed770769f2408969"><td class="memItemLeft" align="right" valign="top"><a id="acec15a02b2a18eb8ed770769f2408969"></a>
<a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#acec15a02b2a18eb8ed770769f2408969">read_transition_probabilities</a> (std::string fname)</td></tr>
<tr class="memdesc:acec15a02b2a18eb8ed770769f2408969"><td class="mdescLeft">&#160;</td><td class="mdescRight">read (row-normalized) transition matrix from file <br /></td></tr>
<tr class="separator:acec15a02b2a18eb8ed770769f2408969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b616984828a8f757859f98a7b720ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#a2b616984828a8f757859f98a7b720ede">transition_counts</a> (std::vector&lt; std::size_t &gt; trajectory, std::vector&lt; std::size_t &gt; concat_limits, std::size_t n_lag_steps, std::size_t i_max)</td></tr>
<tr class="separator:a2b616984828a8f757859f98a7b720ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29434946889924c429ae32d5c9c4013e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#a29434946889924c429ae32d5c9c4013e">weighted_transition_counts</a> (std::vector&lt; std::size_t &gt; trajectory, std::vector&lt; std::size_t &gt; concat_limits, std::size_t n_lag_steps)</td></tr>
<tr class="separator:a29434946889924c429ae32d5c9c4013e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb74cbd76ee8b6f9324dd3b882b4b23"><td class="memItemLeft" align="right" valign="top"><a id="aebb74cbd76ee8b6f9324dd3b882b4b23"></a>
<a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#aebb74cbd76ee8b6f9324dd3b882b4b23">row_normalized_transition_probabilities</a> (<a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> count_matrix, std::set&lt; std::size_t &gt; microstate_names)</td></tr>
<tr class="memdesc:aebb74cbd76ee8b6f9324dd3b882b4b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute transition matrix from counts by normalization of rows <br /></td></tr>
<tr class="separator:aebb74cbd76ee8b6f9324dd3b882b4b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b486d56a698d7df145141cac21dc008"><td class="memItemLeft" align="right" valign="top"><a id="a8b486d56a698d7df145141cac21dc008"></a>
<a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#a8b486d56a698d7df145141cac21dc008">updated_transition_probabilities</a> (<a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> transition_matrix, std::map&lt; std::size_t, std::size_t &gt; sinks, std::map&lt; std::size_t, std::size_t &gt; pops)</td></tr>
<tr class="memdesc:a8b486d56a698d7df145141cac21dc008"><td class="mdescLeft">&#160;</td><td class="mdescRight">update transition matrix after lumping states into sinks <br /></td></tr>
<tr class="separator:a8b486d56a698d7df145141cac21dc008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb2e82d60d7efc807597a46c435a8e3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#a4bb2e82d60d7efc807597a46c435a8e3">single_step_future_state</a> (<a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> transition_matrix, std::set&lt; std::size_t &gt; cluster_names, float q_min, std::map&lt; std::size_t, float &gt; min_free_energy)</td></tr>
<tr class="separator:a4bb2e82d60d7efc807597a46c435a8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac794f6bda2f9a96c46300ae191dd9515"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#ac794f6bda2f9a96c46300ae191dd9515">most_probable_path</a> (std::map&lt; std::size_t, std::size_t &gt; future_state, std::set&lt; std::size_t &gt; cluster_names)</td></tr>
<tr class="separator:ac794f6bda2f9a96c46300ae191dd9515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25b19b43ae12a84dec8ed0206556286"><td class="memItemLeft" align="right" valign="top"><a id="ae25b19b43ae12a84dec8ed0206556286"></a>
std::map&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#ae25b19b43ae12a84dec8ed0206556286">microstate_populations</a> (std::vector&lt; std::size_t &gt; clusters, std::set&lt; std::size_t &gt; cluster_names)</td></tr>
<tr class="memdesc:ae25b19b43ae12a84dec8ed0206556286"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute cluster populations <br /></td></tr>
<tr class="separator:ae25b19b43ae12a84dec8ed0206556286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c6293dca29ab7578334ba9c74b8ea1"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::size_t, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#a59c6293dca29ab7578334ba9c74b8ea1">microstate_min_free_energy</a> (const std::vector&lt; std::size_t &gt; &amp;clustering, const std::vector&lt; float &gt; &amp;free_energy)</td></tr>
<tr class="separator:a59c6293dca29ab7578334ba9c74b8ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b2497eadb5bb6e66f7f500b8c372a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#ad62b2497eadb5bb6e66f7f500b8c372a">path_sinks</a> (std::vector&lt; std::size_t &gt; clusters, std::map&lt; std::size_t, std::vector&lt; std::size_t &gt;&gt; mpp, <a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> transition_matrix, std::set&lt; std::size_t &gt; cluster_names, float q_min, std::vector&lt; float &gt; free_energy)</td></tr>
<tr class="separator:ad62b2497eadb5bb6e66f7f500b8c372a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d7a9ced9fd7372555b1cdec9c3bc2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#afc4d7a9ced9fd7372555b1cdec9c3bc2">lumped_trajectory</a> (std::vector&lt; std::size_t &gt; trajectory, std::map&lt; std::size_t, std::size_t &gt; sinks)</td></tr>
<tr class="separator:afc4d7a9ced9fd7372555b1cdec9c3bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afede836c560ae1779d9789807c69f42a"><td class="memItemLeft" align="right" valign="top"><a id="afede836c560ae1779d9789807c69f42a"></a>
std::tuple&lt; std::vector&lt; std::size_t &gt;, std::map&lt; std::size_t, std::size_t &gt;, <a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#afede836c560ae1779d9789807c69f42a">fixed_metastability_clustering</a> (std::vector&lt; std::size_t &gt; initial_trajectory, <a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> trans_prob, float q_min, std::vector&lt; float &gt; free_energy)</td></tr>
<tr class="memdesc:afede836c560ae1779d9789807c69f42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">run clustering for given Q_min value <br /></td></tr>
<tr class="separator:afede836c560ae1779d9789807c69f42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ffda122e11568a073e97e4a316d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceClustering_1_1MPP.html#aee5ffda122e11568a073e97e4a316d89">main</a> (boost::program_options::variables_map args)</td></tr>
<tr class="memdesc:aee5ffda122e11568a073e97e4a316d89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceClustering_1_1MPP.html" title="functions related to &quot;Most Probable Path&quot;-clustering ">MPP</a> clustering control function and user interface.  <a href="#aee5ffda122e11568a073e97e4a316d89">More...</a><br /></td></tr>
<tr class="separator:aee5ffda122e11568a073e97e4a316d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>functions related to "Most Probable Path"-clustering </p>
<p>This module contains all function for dynamical clustering. In contrast to density-based clustering, can it only be applied to previously clustered trajectories. The idea is to create, based on a microstate input, a coarse-grained model (macrostates). The most probable path depends strongly on the selected timescale (mpp time). If the input was dynamically cored, the mpp time needs to be greater than the coring time. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afc4d7a9ced9fd7372555b1cdec9c3bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4d7a9ced9fd7372555b1cdec9c3bc2">&#9670;&nbsp;</a></span>lumped_trajectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; Clustering::MPP::lumped_trajectory </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>trajectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::size_t, std::size_t &gt;&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lump states based on path sinks and return new trajectory. new microstates will have IDs of sinks. </p>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00400">400</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
<a id="aee5ffda122e11568a073e97e4a316d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ffda122e11568a073e97e4a316d89">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Clustering::MPP::main </td>
          <td>(</td>
          <td class="paramtype">boost::program_options::variables_map&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceClustering_1_1MPP.html" title="functions related to &quot;Most Probable Path&quot;-clustering ">MPP</a> clustering control function and user interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input file with microstate trajectory </td></tr>
    <tr><td class="paramname">basename</td><td>name format for output files </td></tr>
    <tr><td class="paramname">lagtime</td><td>lag for transition estimation in units of frame numbers </td></tr>
    <tr><td class="paramname">qmin-from</td><td>lower limit for metastability (Q_min) </td></tr>
    <tr><td class="paramname">qmin-to</td><td>upper limit for metastability (Q_min) </td></tr>
    <tr><td class="paramname">qmin-step</td><td>stepping for metastability (Q_min) </td></tr>
    <tr><td class="paramname">concat-nframes</td><td>no. of frames per trajectory. </td></tr>
    <tr><td class="paramname">concat-limits</td><td>length of concated trajectories. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Lagtime should be greater than the coring time/ smallest timescale. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00487">487</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
<a id="a59c6293dca29ab7578334ba9c74b8ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c6293dca29ab7578334ba9c74b8ea1">&#9670;&nbsp;</a></span>microstate_min_free_energy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::size_t, float &gt; Clustering::MPP::microstate_min_free_energy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>clustering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_energy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>assign every state the lowest free energy value of all of its frames. </p>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00320">320</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
<a id="ac794f6bda2f9a96c46300ae191dd9515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac794f6bda2f9a96c46300ae191dd9515">&#9670;&nbsp;</a></span>most_probable_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; Clustering::MPP::most_probable_path </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::size_t, std::size_t &gt;&#160;</td>
          <td class="paramname"><em>future_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>cluster_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for every state, compute most probable path by following the 'future_state'-mapping recursively </p>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00288">288</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
<a id="ad62b2497eadb5bb6e66f7f500b8c372a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62b2497eadb5bb6e66f7f500b8c372a">&#9670;&nbsp;</a></span>path_sinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::size_t, std::size_t &gt; Clustering::MPP::path_sinks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::size_t, std::vector&lt; std::size_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>mpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a>&#160;</td>
          <td class="paramname"><em>transition_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>cluster_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>free_energy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute path sinks, i.e. states of highest metastability, and lowest free energy per path. these sinks will be states all other states of the given path will be lumped into. </p>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00337">337</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
<a id="a4bb2e82d60d7efc807597a46c435a8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb2e82d60d7efc807597a46c435a8e3">&#9670;&nbsp;</a></span>single_step_future_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::size_t, std::size_t &gt; Clustering::MPP::single_step_future_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a>&#160;</td>
          <td class="paramname"><em>transition_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>cluster_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::size_t, float &gt;&#160;</td>
          <td class="paramname"><em>min_free_energy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute immediate future (i.e. without lag) of every state from highest probable transitions; exclude self-transitions. </p>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00234">234</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
<a id="a2b616984828a8f757859f98a7b720ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b616984828a8f757859f98a7b720ede">&#9670;&nbsp;</a></span>transition_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> Clustering::MPP::transition_counts </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>trajectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>concat_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n_lag_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i_max</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>count transitions from one to the other cluster with certain lag and return as count matrix (row/col := from/to) </p>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00078">78</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
<a id="a29434946889924c429ae32d5c9c4013e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29434946889924c429ae32d5c9c4013e">&#9670;&nbsp;</a></span>weighted_transition_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceClustering_1_1MPP.html#aab655de2feb4b56dd87bcc0fc6f13974">SparseMatrixF</a> Clustering::MPP::weighted_transition_counts </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>trajectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>concat_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n_lag_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as 'transition_counts', but with reweighting account for differently sized trajectory chunks (as given by concat_limits) </p>

<p class="definition">Definition at line <a class="el" href="mpp_8cpp_source.html#l00113">113</a> of file <a class="el" href="mpp_8cpp_source.html">mpp.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 12 2018 13:18:36 for clustering by &#160;<a href="http://www.doxygen.org/index.html">
doxygen
</a> 1.8.13
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
