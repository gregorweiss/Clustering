#!/usr/bin/env python2

import json, pickle
import numpy as np
import pandas as pd
import argparse
import os
from multiprocessing import Pool
from functools import partial

from md_toolkit import generateTempFilename, parmap
import matplotlib.pyplot as plt

def clusterCenters(data_file, clusters):
  data = np.loadtxt(data_file)
  clusters = np.array(clusters, dtype=int)
  centers = {}
  for i in set(clusters).difference(set([0])):
    centers[i] = np.sum(data[clusters == i], axis=0) / np.sum(clusters == i)
  return centers



def frameDensity(data_file, clusters, density_radius):
  data, cluster_traj = load(data_file, clusters)
  pass


def runHisto2D(data_file, cols, filter_file=None):
  tmp_name = generateTempFilename(ext=".hist2d")
  if filter_file:
    cmd = "frame_filter -p %s %s | histo2d -c %d,%d -b200 -o %s" % (data_file, filter_file, cols[0], cols[1], tmp_name)
    pass
  else:
    cmd = "cat %s | histo2d -c %d,%d -b200 -o %s" % (data_file, cols[0], cols[1], tmp_name)
  os.popen(cmd)
  return tmp_name

p = argparse.ArgumentParser()
p.add_argument(metavar="INPUT", dest="input",
               help="ASCII file with projected dimensions")
p.add_argument("-c", "--config", dest="config", default="supervised_clustering.conf",
               help="config file (default: manual_clustering.conf)")

p.add_argument("--clear-filter", dest="clear_filter", action="store_true",
               help="clear current filter.")
p.add_argument("--save-filter", dest="save_filter", action="store_true",
               help="save current filter, i.e. assign filtered frames to new cluster")

p.add_argument("--filter", dest="filter_frames", default=None,
               help="apply new filter, define columns as comma-separated pair (e.g. '--filter 1,2')")

p.add_argument("--print-clusters", dest="print_clusters", action="store_true",
               help="print list with assigned clusters. first assigned cluster starts with id=1. all frames with id=0 are unassigned.")

p.add_argument("--print-centers", dest="print_centers", action="store_true",
               help="print coordinates of cluster centers.")

#p.add_argument("--print-cluster-interpolation", dest="print_cluster_interpolation", action="store_true",
#               help="print list with assigned clusters after interpolating all unassigned frames and thus assigning them to selected clusters.")
#p.add_argument("--density-radius", dest="density_radius", default=0.5, type=float,
#               help="density radius for cluster interpolation. (default: 0.5)")
p.add_argument("--plot-density", dest="plot_density", default=None,
               help="plot densities around frames as a heatmap along the given dimensions (e.g. '--plot-density 1,2')")
p.add_argument("--neighborhood", dest="neighborhood", default=None,
               help="file with neighborhood information needed for frame densities.")


args = p.parse_args()


# load config
if os.path.isfile(args.config):
  config = json.load(open(args.config, 'r'))
else:
  config = {}


if args.input:
  config['input'] = args.input


if args.filter_frames:
  data_cols = map(int, args.filter_frames.split(','))
  if not len(data_cols) == 2:
    print "error: frame filter must be defined on exactly two comma-separated columns: e.g. --filter 1,2"
    sys.exit()

  # histogram from currently filtered data along given data columns
  if 'cur_filter' in config and not config['cur_filter'] == None:
    filter_filename = generateTempFilename(ext=".filter")
    np.savetxt(filter_filename, np.array(config['cur_filter']), fmt="%d")
    hist_file = runHisto2D(config['input'], cols=(data_cols[0], data_cols[1]), filter_file=filter_filename)
    os.remove(filter_filename)
  else:
    # there is no active filter: use full data set
    hist_file = runHisto2D(config['input'], cols=(data_cols[0], data_cols[1]))

  new_filter = generateTempFilename(ext=".filter")

  # call heatmap with histo and frame-filter
  cmd = ("heatmap --xy-ref %s --close-on-select  --on-select "
         "'frame_identifier --x1 #x1 --y1 #y1 "
         "--x2 #x2 --y2 #y2  -c %d,%d -o %s %s' %s") % (
         config['input'],
         data_cols[0],
         data_cols[1],
         new_filter,
         config['input'],
         hist_file)
  os.popen(cmd)

  if os.path.isfile(new_filter):
    # match filter-ids to full data set -> config['cur_filter']
    new_filter_data = np.loadtxt(new_filter, dtype=int, usecols=(0,)).tolist()
    if 'cur_filter' in config and not config['cur_filter'] == None:
      config['cur_filter'] = list(set(new_filter_data).intersection(config['cur_filter']))
    else:
      config['cur_filter'] = new_filter_data

  try:
    os.remove(new_filter)
  except: pass

  os.remove(hist_file)


def clear_filter():
  del config['cur_filter']


if args.clear_filter:
  clear_filter()


if args.save_filter:
  if not 'cluster_traj' in config:
    config['cluster_traj'] = np.zeros(np.loadtxt(config['input']).shape[0], dtype=int).tolist()
  cluster_id = max(set(config['cluster_traj'])) + 1
  for i in config['cur_filter']:
    config['cluster_traj'][i] = cluster_id
  clear_filter()


if args.print_clusters:
  if 'cluster_traj' in config:
    for i in config['cluster_traj']:
      print i


if args.print_centers:
  centers = clusterCenters(config['input'], config['cluster_traj'])
  for i in centers:
    print str(i) + " ", centers[i]


if args.plot_density:
  data_cols = map(int, args.plot_density.split(','))
  if not len(data_cols) == 2:
    print "error: surface for density plotting must be defined on exactly two comma-separated columns: e.g. --plot-density 1,2"
    sys.exit()
  if not args.neighborhood:
    print "error: need neighborhood information"
    sys.exit()
  

  input_data = np.loadtxt(config["input"], usecols=(data_cols[0]-1, data_cols[1]-1))
  iterator = pd.read_csv(args.neighborhood, sep=" ", header=None, iterator=True, usecols=[0,1])

  populations = np.zeros(input_data.shape[0])

  while True:
    try:
      next_row = iterator.get_chunk(1)
      i, j = int(next_row[0]), int(next_row[1])
      populations[i] += 1
      populations[j] += 1
    except StopIteration:
      break

  density_surface = np.array((input_data.T[0], input_data.T[1], populations.T)).T
  pickle.dump(density_surface.tolist(), open('test_surface', 'w'))
  extent = (min(density_surface.T[0]), max(density_surface.T[0]), max(density_surface.T[1]), min(density_surface.T[1]))
  plt.imshow(density_surface, extent=extent)
  plt.show()



# save config
json.dump(config, open(args.config, 'w'), indent=2)

